---
title: "Simulating Immigration -- Small Scale"
author: "Alex Bartolo"
date: "2021-08-11"
output: html_document
---

# Setup


Goal: Use just a small subset of data with coalesc_abc() since it won't work with larger set of just Maine data. My approach has been to continuously scale down; first to only state-level species pool (which also takes too long to run) and now Route 01 of Maine as the species pool. Here stop 01 (out of the 50 stops) will be a local community. Each subsequent stop can act as another community.

```{r, setup, message = FALSE, warning = FALSE}

# clearing environment
rm(list = ls())

# setting work directory
setwd('~/academics/gradschool/CSULB/thesis/idea02_gradients/scripts')

# necessary packages
library(ecolottery) # obviouslyl
library(tidyverse) # for data manipulation help
library(parallel) # for using multiple cores for faster analysis
library(vegan) # just to reference BCI data


# loading csv with all data from state of Maine.
maine <- read.csv('maine.csv')

```


First extracting route 01 from Maine data to create metacommunity. All of route 01 will be the metacommunity. Table output shows 43 values of 1 for route number, which is good.
```{r}
maine01 <- maine[maine$Route == 1,]
table(maine01$Route) # checks out
```



# Building Species Pool

The coalesc() function needs a dataframe with two columns. First (label) is indexing values and second (species) is repeated AOU codes. Each AOU code is repeated the number of time the bird is observed. 
```{r}

route01_pool <- vector() # empty vector to fill with results of loop

for (i in 1:length(maine01$AOU)){
  a <- rep(maine01$AOU[i], maine01$route_totals[i])
  # repeat AOU codes by the number of times they occur in route total column.
  route01_pool <- c(route01_pool, a)
  # add repeated AOU codes to empty vector
}

# taking for loop output and and re-assigning to data frame with numbered columns and species AOU data
route01_pool <- data.frame(label = 1:length(route01_pool), species = route01_pool)
head(route01_pool)

```


Checking to see if newly made route01_pool data matches what's in maine01 under "route totals." And it does!
```{r}
# take table of route01_pool, species data and put into dataframe for easier viewing.
head(data.frame(table(route01_pool$species)))

# above should should match data taken directly from maine01, with AOU and route_totals column.
head(maine01[, c('AOU', 'route_totals')])

```



# Creating One Local Community

This is just to test coalesc() and coalesc_abc(). In reality I'll want to build a function that uses parallel computing (parLapply) to run the coalesc functions over a list of communities. FOr now, just making sure the coalesc functions work and that I can understand them, so only using one community.
```{r}
# putting AOU values and column 'Stop1' into new dataframe. 
maine_stop01 <- select(maine01, AOU, Stop1)

# making observed community, needs repeated AOU values from maine_stop01
stop01_comm <- vector()
for (i in 1:length(maine_stop01$AOU)){
  a <- rep(maine_stop01$AOU[i], maine_stop01$Stop1[i])
  stop01_comm <- c(stop01_comm, a)
}
stop01_comm
# checks out, and matches maine_stop01 data; checked manually.

# putting in a dataframe with labels for ecolottery: 
stop01_comm <- data.frame(label = 1:length(stop01_comm), 
                          species = stop01_comm)
stop01_comm

```

So "stop01_com" has two observations of species 5600 (CHSP), one of 6710 (PIWA), and three of 7610 (AMRO). This community is very small, only three species and six individuals.
```{r}

table(stop01_comm$species)

```


# Using Function coalesc()
Start with trying to use coalesc() to get used to output and necessary inputs, the data format it requires, etc.

**Note: with coalesc() you only need the total community size for simulations. That is, J = 100, or 500, or whatever your local commmunity size is.** coalesc_abc() requires an actual list with AOU codes // species repeated the number of times they occur. 
```{r}
# defining range of m values to use. 
# example vignette does runif() with larger size but that will take too long.
m_samp <- seq(from = 0.05, to = 1, by = 0.05)

# defining J, number of species in local community, as 6. 
J <- sum(table(stop01_comm$species))

# setting up output list.
coalesc_output <- list()

# loop to fill coalesc_output with iterations of coalesc() with values taken from m.
for (i in 1:length(m_samp)){
  temp <- coalesc(J = J, m = m_samp[i], pool = route01_pool, 
                  traits = NULL, filt = NULL)
  coalesc_output[[i]] <- temp$com
}
coalesc_output[1:5]

```


# Using Function coalesc_abc()

## Setup and Data Wrangling

With some modifications this code works! Runs in 10 - 12 minutes. But I need to better understand the abc output... f.sumstats code taken entirely from ecolottery vignette. Can be modified as needed. 
```{r, eval = FALSE}
f.sumstats <- function(com) array(dimnames=list(c("cwm", "cwv", "cws",
                                                 "cwk", "S", "Es")), 
                                  c(mean(com[,2]), var(com[,2]), 
                                    e1071::skewness(com[,2]), 
                                    e1071::kurtosis(com[,2]),
                                    vegan::specnumber(table(com[,2])), 
                                    vegan::diversity(table(com[,2]))))

# system.time() lets me know how long the code takes to run.
system.time(test <- coalesc_abc(comm.obs = stop01_comm, pool = route01_pool, 
                               traits = NULL, f.sumstats = f.sumstats, 
                               tol = 0.01, parallel = TRUE))

```


Saving 'test' output for easier loading. Right now above chunk runs in about 650 seconds, or about 10 minutes. As always, load with load()
```{r}

# save(test, file = 'tinydata-coalesc_abc-output')

load('tinydata-coalesc_abc-output')
# auto loads as object "test"

str(test) # quick look at output
```


Printing first five lines of each element of output for reference. Need to use head() because it's a huge object.
```{r}
head(test$par)
head(test$obs)
head(test$obs.scaled)
head(test$ss)

```



## Putting It Together

I need a function that:
1. can extract and build communities in the format that coalesc_abc() wants. That is, AMRO AMRO AMRO, CHISP, PIWA, PIWA.
+ output should be a list, or each community can be a row in a database; whichever is easier.
2. runs coalesc_abc() on every local community
2. does so for the range of m values
3. returns results that include m value used in simulation
4. runs via parallels (parLapply)


Let's try doing this as a for loop.
```{r}
stop_comms <- list()

for (i in 10:59) {
  temp <- vector()
  stops <- data.frame()
  (stops <- maine01[, c(9, i)])
 
   for (j in 1:length(stops$AOU)) {
    (a <- rep(stops$AOU[j], stops[j, 2]))
    (temp <- c(temp, a))
   }
     for (k in 1:50){
       stop_comms[[k]] <- data.frame(number = 1:length(temp), species = temp)}
}

stop_comms[1:4]

```

As we can see, this doesn't work; it replicates the last row of observations for all of the list objects. 
```{r}
# grabbing first output of stop_comms, making table of $species and putting into data.frame for easy viewing.
data.frame(table(stop_comms[[1]]$species))

# comparing with data taken directly from maine01, and we can see they have the same output.
maine01[, c(9, 59)][which(stops$Stop50 != 0) , ]



# Troubleshooting notes from Emma:
# use if else statement!!!!
# issue is that it's trying to repeat '0' times

# stops[42, 2] = zero then skip or break, etc
# next, if statement is true, then it goes on to the next part of the "if" statement.

```


What if each community is a line in a database? Here I want to replicate the format of the BCI tree data provided by package 'vegan'.
```{r}

data(BCI) # loading BCI data
BCI[1:5, 1:8] # looking at short snippet for reference.

comms_matrix <- data.frame(matrix(nrow = length(maine01[ , 10:59]), 
                            ncol = length(maine01$AOU)))
colnames(comms_matrix) <- unique(maine01$AOU)
head(comms_matrix)


```


Building outside for loop to break down the steps I need to take.
```{r, eval = FALSE, echo = FALSE}

allstops_names <- colnames(maine01[10:59])
# taking vector with names of all the stops; 'Stop1, 'Stop2', and so on. This is for reference in the for loop.

aou_names <- unique(maine$AOU)
# making vector of AOU values. again, will reference this in for loop. i think building things this way will allow any functions i create from here on out to have some flexibility...

maine01[allstops_names]
# selects all columns 1:50 for the different stops (just testing)



# ---------------------- step 01 of loop -------------------------

a <- as.numeric(maine01[allstops_names][which(maine01$AOU == aou_names[1]), ])
# selects the row for which AOU matches the first value in aou_names. so this is always going to start at 1720, then move onto the next value in aou_names. this is good because we want it to flexibly run through the list of aou_names.

comms_matrix[, which(maine01$AOU == aou_names[1])] <- a
# take a and fill out new database, but only do the column for which 

comms_matrix$'1720'
# got it!!!



# ----------------------- step 02 --------------------------

a <- as.numeric(maine01[allstops_names][which(maine01$AOU == aou_names[2]), ])

comms_matrix[, which(maine01$AOU == aou_names[2])] <- a

comms_matrix[, 2]
comms_matrix
# got it!!!

# to check:
table(as.numeric(maine[2, 10:59]) == comms_matrix$'2010')
# no false values, so they match!

```


Now place what I did above into for loop with 'i' for each step 1:length(aou_names). 
``` {r}

allstops_names <- colnames(maine01[10:59])
# creating names for reference within for loop. this lets the for loop be more flexible, or at least i think.
aou_names <- unique(maine$AOU)
# making vector of unique AOU names for reference in for loop.

for (i in 1:length(aou_names)) { 
  
# does length(aout_names) need to be unique()? will eventually have to reckon with the fact that some communities might have repated AOU values... or should they? maybe they shouldn't if we take averages across years... because the repitition of AOU codes only comes with years right? check this and think about it. 
  
  a <- as.numeric(maine01[allstops_names][which(maine01$AOU == aou_names[i]), ])
  comms_matrix[, which(maine01$AOU == aou_names[i])] <- a

}

# oh my fucking god i think that worked. 

```


One way to check and see if this worked: create table of values from maine01 and see if there's any discrepancies
```{r}

# check last row, another way to do it: 
table(as.numeric(maine01[which(maine01$AOU == aou_names[43]), allstops_names]) == comms_matrix[ , 43])

# as we can see, all values here are TRUE, so there's a perfect match between data from the 43rd value of aou_names in maine01 and in the comms_matrix. Any discrepancies would have resulted in a FALSE value.


```



## Putting Into coalesc_abc() function


```{r}

f.sumstats <- function(com) array(dimnames=list(c("cwm", "cwv", "cws",
                                                 "cwk", "S", "Es")), 
                                  c(mean(com[,2]), var(com[,2]), 
                                    e1071::skewness(com[,2]), 
                                    e1071::kurtosis(com[,2]),
                                    vegan::specnumber(table(com[,2])), 
                                    vegan::diversity(table(com[,2]))))


# system.time() lets me know how long the code takes to run.
system.time(test <- coalesc_abc(comm.obs = comms_matrix, # observed comm data
                                multi = 'tab', # because i'm providing site-species 
                                # matrix. rows = communities, col = AOU codes.
                                pool = route01_pool,
                                traits = NULL, 
                                f.sumstats = f.sumstats, 
                                tol = 0.01, 
                                parallel = TRUE))




```




```{r}

f.sumstats <- function(com) array(dimnames=list(c("cwm", "cwv", "cws",
                                                 "cwk", "S", "Es")), 
                                  c(mean(com[,2]), var(com[,2]), 
                                    e1071::skewness(com[,2]), 
                                    e1071::kurtosis(com[,2]),
                                    vegan::specnumber(table(com[,2])), 
                                    vegan::diversity(table(com[,2]))))


# system.time() lets me know how long the code takes to run.
system.time(test <- coalesc_abc(comm.obs = comms_matrix, # observed comm data
                                multi = 'tab', # because i'm providing site-species 
                                # matrix. rows = communities, col = AOU codes.
                                pool = route01_pool,
                                traits = NULL, 
                                f.sumstats = f.sumstats, 
                                tol = 0.01, 
                                parallel = TRUE))
```

















# Sketchpad
These are random notes, test snippets of code, etc, which are not included in the Markdown output.
```{r, eval = FALSE, echo = FALSE}

stop_comms <- list()
temp <- vector()

for (i in 10:59) {
  (stops <- maine01[, c(9, i)]) # i needs to go from 10 - 60
  
  for (j in 1:length(stops$AOU)){
    a <- rep(stops$AOU[j], stops[j, 2]) # j goes from 1:length of AOU codes 
    temp <- c(temp, a)
    
    for (k in 1:50) {
      stop_comms[[k]] <- data.frame(number = 1:length(temp), species = temp)
    }
  }
}


########################################################################

# this works outside of for loops: done step by step.

stop_comms <- list()
temp <- vector()

(stops <- maine01[, c(9, 10)]) # i needs to go from 10 - 60

(a <- rep(stops$AOU[22], stops[22, 2])) # j goes from 1:length of AOU codes 
(temp <- c(temp, a))

stop_comms[[1]] <- data.frame(number = 1:length(temp), species = temp)

stop_comms

########################################################################


# can't put output of for loop directly in data.frame; it's too complicated. you need to pre-define the number of columns // rows which makes it super complicated. or, do this way?

(stops <- maine01[, c(9, 10)])

temp <- vector()
stop_comms <- list()

for (i in 1:length(stops$AOU)) {
(a <- rep(stops$AOU[i], stops[i, 2])) # j goes from 1:length of AOU codes 
(temp <- c(temp, a))
number <- 1:length(temp)
stop_comms[[1]] <- cbind(number, temp)
stop_comms[[1]] <- data.frame(stop_comms[[1]])
}

str(stop_comms)

#####################################################################



























# this works, use as baseline for building functions // for loop.
###########################################################################

stop_comms <- list()
stop_comms2 <- list()
# above must only be run once 

for (i in 10:59) {
  (stop_comms[[i]] <- maine01[, c(9, i)]
}

for (i in 1:length(stop_comms[[1]]$AOU)){
  a <- rep(stop_comms[[1]]$AOU[1], stop_comms[[1]][1,2])
  temp <- c(temp, a)
  stop_comms2[[1]] <- data.frame(number = 1:length(temp), species = temp)
}


###########################################################################









```

